#pragma once

#if !defined(HAVE_TYPE_TRAITS_H) || HAVE_TYPE_TRAITS_H
#include_next <type_traits>
#endif

#if defined(HAVE_STD_REMOVE_REFERENCE) && !HAVE_STD_REMOVE_REFERENCE

namespace std {
    template<class T> struct remove_reference      { typedef T type; };
    template<class T> struct remove_reference<T&>  { typedef T type; };
    template<class T> struct remove_reference<T&&> { typedef T type; };
}

#endif

#if defined(HAVE_STD_UNDERLYING_TYPE) && !HAVE_STD_UNDERLYING_TYPE

// namespace std {
    template< class T >
    struct underlying_type;

    template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

    template< class T, class V >
    V to_underlying(T) {
        return underlying_type(V);
    }
    
// }

#endif
